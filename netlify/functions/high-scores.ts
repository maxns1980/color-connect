
import type { Handler, HandlerEvent, HandlerContext } from "@netlify/functions";
import { getStore } from "@netlify/blobs";

// Define HighScoreEntry interface matching the one in src/types.ts
interface HighScoreEntry {
  name: string;
  score: number;
  date: string; // Date string as generated by the client
}

const BLOB_STORE_NAME = 'colorConnectScores'; // Unique store name for this app's high scores
const SCORES_BLOB_KEY = 'highScores'; // Key for the JSON blob containing the scores array
const MAX_HIGH_SCORES_SERVER = 20; // Maximum number of high scores to store

// Helper function to get scores from Netlify Blobs
const getScoresFromBlob = async (): Promise<HighScoreEntry[]> => {
  try {
    const store = getStore(BLOB_STORE_NAME);
    // Retrieve the scores, expecting JSON. If not found, blobStore.get() returns undefined.
    const currentScoresData = await store.get(SCORES_BLOB_KEY, { type: 'json' });
    // Ensure it's an array, default to empty if no scores or invalid data.
    if (Array.isArray(currentScoresData)) {
      return currentScoresData as HighScoreEntry[];
    }
    return [];
  } catch (error) {
    console.error("Error getting scores from blob:", error);
    return []; // Return empty array on error to prevent breaking frontend logic dependent on an array
  }
};

// Helper function to save scores to Netlify Blobs
const saveScoresToBlob = async (scores: HighScoreEntry[]): Promise<void> => {
  try {
    const store = getStore(BLOB_STORE_NAME);
    await store.setJSON(SCORES_BLOB_KEY, scores);
  } catch (error) {
    console.error("Error saving scores to blob:", error);
    throw error; // Re-throw to be handled by the main handler
  }
};

const handler: Handler = async (event: HandlerEvent, context: HandlerContext) => {
  const headers = {
    'Access-Control-Allow-Origin': '*', // For development. In production, specify your app's domain.
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  // Handle CORS preflight requests
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 204, // No Content
      headers,
    };
  }

  if (event.httpMethod === 'GET') {
    try {
      const scores = await getScoresFromBlob();
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify(scores),
      };
    } catch (error) {
      console.error("Error in GET /api/high-scores:", error);
      return {
        statusCode: 500,
        headers,
        body: JSON.stringify({ message: 'Failed to retrieve high scores.', error: (error as Error).message }),
      };
    }
  }

  if (event.httpMethod === 'POST') {
    try {
      if (!event.body) {
        return { statusCode: 400, headers, body: JSON.stringify({ message: 'Request body is missing.' }) };
      }
      
      let newEntry: HighScoreEntry;
      try {
        newEntry = JSON.parse(event.body);
      } catch (parseError) {
        return { statusCode: 400, headers, body: JSON.stringify({ message: 'Invalid JSON in request body.', error: (parseError as Error).message }) };
      }

      // Basic validation for the new entry
      if (!newEntry.name || typeof newEntry.name !== 'string' || newEntry.name.trim().length === 0 || newEntry.name.length > 15) {
        return { statusCode: 400, headers, body: JSON.stringify({ message: 'Invalid player name. Must be 1-15 characters.' }) };
      }
      if (typeof newEntry.score !== 'number' || newEntry.score < 0) {
        return { statusCode: 400, headers, body: JSON.stringify({ message: 'Invalid score. Must be a non-negative number.' }) };
      }
      if (!newEntry.date || typeof newEntry.date !== 'string' || !/^\d{2}\.\d{2}\.\d{4}$/.test(newEntry.date)) {
         return { statusCode: 400, headers, body: JSON.stringify({ message: 'Invalid date format. Expected DD.MM.YYYY.' }) };
      }

      const currentScores = await getScoresFromBlob();
      currentScores.push(newEntry);
      
      // Sort scores in descending order
      currentScores.sort((a, b) => b.score - a.score);
      
      // Keep only the top N scores
      const updatedScores = currentScores.slice(0, MAX_HIGH_SCORES_SERVER);
      
      await saveScoresToBlob(updatedScores);

      return {
        statusCode: 200, // Successfully processed, returning the updated list
        headers,
        body: JSON.stringify(updatedScores),
      };
    } catch (error) {
      console.error("Error in POST /api/high-scores:", error);
      return {
        statusCode: 500,
        headers,
        body: JSON.stringify({ message: 'Failed to submit high score.', error: (error as Error).message }),
      };
    }
  }

  // Method not supported
  return {
    statusCode: 405, // Method Not Allowed
    headers,
    body: JSON.stringify({ message: `Method ${event.httpMethod} Not Allowed` }),
  };
};

export { handler };
